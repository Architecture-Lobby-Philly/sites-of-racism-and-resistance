{"version":3,"sources":["webpack:///./node_modules/@phila/vue-mapping/src/mapbox/layer/layerMixin.js","webpack:///./node_modules/@phila/vue-mapping/src/mapbox/layer/GeojsonLayer.js","webpack:///./node_modules/@phila/vue-mapping/src/mapbox/lib/withEvents.js","webpack:///./node_modules/@phila/vue-mapping/src/mapbox/lib/layerEvents.js"],"names":["mapboxSourceProps","sourceId","type","String","required","source","Object","default","undefined","mapboxLayerStyleProps","layerId","layer","before","componentProps","clearSource","Boolean","replaceSource","replace","mixins","props","inject","initial","computed","this","map","isSourceLoaded","getLayer","getSource","minzoom","$watch","next","setLayerZoomRange","maxzoom","paint","prop","keys","setPaintProperty","deep","layout","setLayoutProperty","filter","setFilter","removeLayer","err","$_emitEvent","error","removeSource","methods","event","$_emitMapEvent","events","$listeners","forEach","eventName","includes","on","$_emitLayerMapEvent","off","data","dataType","$_watchSourceLoading","beforeId","moveLayer","$destroy","name","querySourceFeatures","geometry","queryRenderedFeatures","layers","clusterId","Promise","resolve","reject","mapSource","Error","getClusterExpansionZoom","zoom","getClusterChildren","features","args","getClusterLeaves","console","log","setData","$_deferredMount","$props","loadImage","$attrs","icon","image","addImage","bind","addSource","$_addLayer","$_bindLayerEvents","existed","id","addLayer","featureId","state","params","setFeatureState","getFeatureState","sourceLayer","key","removeFeatureState","$emit","component","mapboxEvent"],"mappings":"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","file":"static/js/pvm_MglGeojsonLayer.js","sourcesContent":["// import withRegistration from \"../../lib/withRegistration\";\nimport withEvents from \"../lib/withEvents\";\n\nconst mapboxSourceProps = {\n  sourceId: {\n    type: String,\n    required: true,\n  },\n  source: {\n    type: [ Object, String ],\n    default: undefined,\n  },\n};\n\nconst mapboxLayerStyleProps = {\n  layerId: {\n    type: String,\n    required: true,\n  },\n  layer: {\n    type: Object,\n    required: true,\n  },\n  before: {\n    type: String,\n    default: undefined,\n  },\n};\n\nconst componentProps = {\n  clearSource: {\n    type: Boolean,\n    default: true,\n  },\n  replaceSource: {\n    type: Boolean,\n    default: false,\n  },\n  replace: {\n    type: Boolean,\n    default: false,\n  },\n};\n\nexport default {\n  mixins: [ withEvents ],\n  props: {\n    ...mapboxSourceProps,\n    ...mapboxLayerStyleProps,\n    ...componentProps,\n  },\n\n  inject: [ \"mapbox\", \"map\" ],\n\n  data() {\n    return {\n      initial: true,\n    };\n  },\n\n  computed: {\n    sourceLoaded() {\n      return this.map ? this.map.isSourceLoaded(this.sourceId) : false;\n    },\n    mapLayer() {\n      return this.map ? this.map.getLayer(this.layerId) : null;\n    },\n    mapSource() {\n      return this.map ? this.map.getSource(this.sourceId) : null;\n    },\n  },\n\n  created() {\n    if (this.layer.minzoom) {\n      this.$watch(\"layer.minzoom\", function(next) {\n        if (this.initial) {\n          return;\n        }\n        this.map.setLayerZoomRange(this.layerId, next, this.layer.maxzoom);\n      });\n    }\n\n    if (this.layer.maxzoom) {\n      this.$watch(\"layer.maxzoom\", function(next) {\n        if (this.initial) {\n          return;\n        }\n        this.map.setLayerZoomRange(this.layerId, this.layer.minzoom, next);\n      });\n    }\n\n    if (this.layer.paint) {\n      this.$watch(\n        \"layer.paint\",\n        function(next) {\n          if (this.initial) {\n            return;\n          }\n          if (next) {\n            for (let prop of Object.keys(next)) {\n              this.map.setPaintProperty(this.layerId, prop, next[prop]);\n            }\n          }\n        },\n        { deep: true },\n      );\n    }\n\n    if (this.layer.layout) {\n      this.$watch(\n        \"layer.layout\",\n        function(next) {\n          if (this.initial) {\n            return;\n          }\n          if (next) {\n            for (let prop of Object.keys(next)) {\n              this.map.setLayoutProperty(this.layerId, prop, next[prop]);\n            }\n          }\n        },\n        { deep: true },\n      );\n    }\n\n    if (this.layer.filter) {\n      this.$watch(\n        \"layer.filter\",\n        function(next) {\n          if (this.initial) {\n            return;\n          }\n          this.map.setFilter(this.layerId, next);\n        },\n        { deep: true },\n      );\n    }\n\n    // if (this.layer.tiles) {\n    //   this.$watch(\n    //     \"layer\",\n    //     function(next) {\n    //       console.log('watch layer tiles is firing, next:', next);\n    //       if (this.initial) return;\n    //       // this.map.removeLayer(this.layerId);\n    //       this.map.addLayer(next);\n    //       // this.map.setFilter(this.layerId, next);\n    //     },\n    //     { deep: true }\n    //   );\n    // }\n  },\n\n  beforeDestroy() {\n    // console.log('layerMixin beforeDestroy is running, this.layerId:', this.layerId, 'this.clearSource:', this.clearSource, 'this.map:', this.map, 'this.map.loaded():', this.map.loaded());\n    // if (this.map && this.map.loaded()) {\n    try {\n      // console.log('layerMixin beforeDestroy if map and maploaded try is running')\n      this.map.removeLayer(this.layerId);\n    } catch (err) {\n      // console.log('layerMixin beforeDestroy error 1 is running')\n      this.$_emitEvent(\"layer-does-not-exist\", {\n        layerId: this.sourceId,\n        error: err,\n      });\n    }\n    if (this.clearSource) {\n      // console.log('layerMixin beforeDestroy if clearSource is running')\n      try {\n        // console.log('layerMixin beforeDestroy if clearSource try is running');\n        this.map.removeSource(this.sourceId);\n      } catch (err) {\n        this.$_emitEvent(\"source-does-not-exist\", {\n          sourceId: this.sourceId,\n          error: err,\n        });\n      }\n    }\n    // }\n  },\n\n  methods: {\n    $_emitLayerMapEvent(event) {\n      return this.$_emitMapEvent(event, { layerId: this.layerId });\n    },\n\n    $_bindLayerEvents(events) {\n      Object.keys(this.$listeners).forEach(eventName => {\n        if (events.includes(eventName)) {\n          this.map.on(eventName, this.layerId, this.$_emitLayerMapEvent);\n        }\n      });\n    },\n\n    $_unbindEvents(events) {\n      if (this.map) {\n        events.forEach(eventName => {\n          this.map.off(eventName, this.layerId, this.$_emitLayerMapEvent);\n        });\n      }\n    },\n\n    $_watchSourceLoading(data) {\n      if (data.dataType === \"source\" && data.sourceId === this.sourceId) {\n        this.$_emitEvent(\"layer-source-loading\", { sourceId: this.sourceId });\n        this.map.off(\"dataloading\", this.$_watchSourceLoading);\n      }\n    },\n\n    move(beforeId) {\n      this.map.moveLayer(this.layerId, beforeId);\n      this.$_emitEvent(\"layer-moved\", {\n        layerId: this.layerId,\n        beforeId: beforeId,\n      });\n    },\n\n    remove() {\n      this.map.removeLayer(this.layerId);\n      this.map.removeSource(this.sourceId);\n      this.$_emitEvent(\"layer-removed\", { layerId: this.layerId });\n      this.$destroy();\n    },\n  },\n\n  render() {},\n};\n","import layerEvents from \"../lib/layerEvents\";\nimport mixin from \"./layerMixin\";\n\nexport default {\n  name: \"GeojsonLayer\",\n  mixins: [ mixin ],\n\n  computed: {\n    getSourceFeatures() {\n      return filter => {\n        if (this.map) {\n          return this.map.querySourceFeatures(this.sourceId, { filter });\n        }\n        return null;\n      };\n    },\n\n    getRenderedFeatures() {\n      return (geometry, filter) => {\n        if (this.map) {\n          return this.map.queryRenderedFeatures(geometry, {\n            layers: [ this.layerId ],\n            filter,\n          });\n        }\n        return null;\n      };\n    },\n\n    getClusterExpansionZoom() {\n      return clusterId => {\n        return new Promise((resolve, reject) => {\n          if (this.mapSource) {\n            this.mapSource.getClusterExpansionZoom(clusterId, (err, zoom) => {\n              if (err) {\n                return reject(err);\n              }\n              return resolve(zoom);\n            });\n          } else {\n            return reject(\n              new Error(`Map source with id ${this.sourceId} not found.`),\n            );\n          }\n        });\n      };\n    },\n\n    getClusterChildren() {\n      return clusterId => {\n        return new Promise((resolve, reject) => {\n          const source = this.mapSource;\n          if (source) {\n            source.getClusterChildren(clusterId, (err, features) => {\n              if (err) {\n                return reject(err);\n              }\n              return resolve(features);\n            });\n          } else {\n            return reject(\n              new Error(`Map source with id ${this.sourceId} not found.`),\n            );\n          }\n        });\n      };\n    },\n\n    getClusterLeaves() {\n      return (...args) => {\n        return new Promise((resolve, reject) => {\n          if (this.mapSource) {\n            this.mapSource.getClusterLeaves(...args, (err, features) => {\n              if (err) {\n                return reject(err);\n              }\n              return resolve(features);\n            });\n          } else {\n            return reject(\n              new Error(`Map source with id ${this.sourceId} not found.`),\n            );\n          }\n        });\n      };\n    },\n  },\n\n  created() {\n    console.log('GeojsonLayer.js created is running, this.sourceId:', this.sourceId, 'this.source:', this.source);\n    if (this.source) {\n      this.$watch(\n        \"source.data\",\n        function(next) {\n          if (this.initial) {\n            return;\n          }\n          this.mapSource.setData(next);\n        },\n        { deep: true },\n      );\n    }\n    this.$_deferredMount();\n  },\n\n  methods: {\n    $_deferredMount() {\n      // console.log('GeojsonLayer.js $_deferredMount is running, this.sourceId:', this.sourceId, 'this.source:', this.source);\n      // this.map = payload.map;\n      this.map.on(\"dataloading\", this.$_watchSourceLoading);\n      if (this.source) {\n        const source = {\n          type: \"geojson\",\n          ...this.source,\n        };\n        try {\n          console.log('try map.addSource is starting');\n          if (this.$props.layer.layout['icon-image']) {\n            this.map.loadImage(\n              this.$attrs.icon,\n              function(error, image) {\n                // console.log('inside loadImage, this.$props.layer.layout[icon-image]:', this.$props.layer.layout['icon-image'], 'image:', image, 'this.$attrs.icon:', this.$attrs.icon);\n                this.map.addImage(this.$props.layer.layout['icon-image'], image);\n              }.bind(this),\n            );\n          }\n          this.map.addSource(this.sourceId, source);\n          // console.log('try map.addSource is ending');\n        } catch (err) {\n          console.log('catch err is running, err:', err);\n          if (this.replaceSource) {\n            this.map.removeSource(this.sourceId);\n            this.map.addSource(this.sourceId, source);\n          }\n        }\n      }\n      // console.log('GeojsonLayer.js $_deferredMount, about to $_addLayer');\n      this.$_addLayer();\n      // console.log('GeojsonLayer.js $_deferredMount, after $_addLayer');\n      this.$_bindLayerEvents(layerEvents);\n      this.map.off(\"dataloading\", this.$_watchSourceLoading);\n      this.initial = false;\n    },\n\n    $_addLayer() {\n      // console.log('GeojsonLayer.js $_addLayer is starting');\n      let existed = this.map.getLayer(this.layerId);\n      if (existed) {\n        if (this.replace) {\n          this.map.removeLayer(this.layerId);\n        } else {\n          this.$_emitEvent(\"layer-exists\", { layerId: this.layerId });\n          return existed;\n        }\n      }\n      const layer = {\n        id: this.layerId,\n        source: this.sourceId,\n        ...this.layer,\n      };\n      console.log('$_addLayer is still running, layer:', layer);\n      this.map.addLayer(layer, this.before);\n      // console.log('$_addLayer after map.addLayer');\n      this.$_emitEvent(\"added\", { layerId: this.layerId });\n    },\n\n    setFeatureState(featureId, state) {\n      if (this.map) {\n        const params = { id: featureId, source: this.source };\n        return this.map.setFeatureState(params, state);\n      }\n    },\n\n    getFeatureState(featureId) {\n      if (this.map) {\n        const params = { id: featureId, source: this.source };\n        return this.map.getFeatureState(params);\n      }\n    },\n\n    removeFeatureState(featureId, sourceLayer, key) {\n      if (this.map) {\n        const params = {\n          id: featureId,\n          source: this.source,\n          sourceLayer,\n        };\n        return this.map.removeFeatureState(params, key);\n      }\n    },\n  },\n};\n","export default {\n  methods: {\n    /**\n     * Emit Vue event with additional data\n     *\n     * @param {string} name EventName\n     * @param {Object} [data={}] Additional data\n     */\n    $_emitEvent(name, data = {}) {\n      // console.log('$_emitEvent is running, name:', name, 'data:', data, 'this.map:', this.map);\n      this.$emit(name, {\n        map: this.map,\n        component: this,\n        ...data,\n      });\n    },\n\n    /**\n     * Emit Vue event with Mapbox event as additional data\n     *\n     * @param {Object} event\n     */\n    $_emitMapEvent(event, data = {}) {\n      // console.log('withEvents.js, $_emitMapEvent is running');\n      this.$_emitEvent(event.type, { mapboxEvent: event, ...data });\n    },\n  },\n};\n","export default [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"mousemove\",\n  \"mouseenter\",\n  \"mouseleave\",\n  \"mouseover\",\n  \"mouseout\",\n  \"contextmenu\",\n  \"touchstart\",\n  \"touchend\",\n  \"touchcancel\",\n];\n"],"sourceRoot":""}